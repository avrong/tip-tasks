#import "template.typ": *
#import "@preview/curryst:0.1.1"

// Take a look at the file `template.typ` in the file panel
// to customize this template and discover how it works.
#show: project.with(
  title: "Задания по курсу\n «Статический анализ программ»",
  authors: (
    "Алексей Трифонов",
  ),
  date: "5 июня 2024",
)

= Лекция 2

=== Что будет, если в нашу систему ввести тип Bool?

#let bool = "bool"
#let int = "int"
#let output = "output"

Так как появляются типы `true` и `false`, которые до этого использовались как `1` и `0` соответственно, добавляются и изменяются следующие правила:
$
E_1 == E_2 : [|E_1|] = [|E_2|] and [|E_1 == E_2|] = bool \
E_1 > E_2 : [|E_1|] = [|E_2|] = int and [|E_1 > E_2|] = bool \
E_1 op E_2 : [|E_1|] = [|E_2|] = [|E_1 op E_2|] = int \
output E : [|E|] = alpha \
"if" (E)S : [|E|] = bool \
"if" (E)S_1 "else" S_2 : [|E|] = bool \
"while" (E)S : [|E|] = bool
$

Precision не изменяется, так как система остается sound.
Recall --- ухудшится, так как в новой реализации больше нельзя будет использовать результаты выражений которые ранее возвращались как `int`.

=== Что будет, если в нашу систему ввести тип Array?

#let value = "value"

Синтаксис (arr -- $T[]$, T -- $[|value|]$, idx -- $int$):

```
arr[idx] = x;
y = arr[idx];
arr = {};
arr = {2, 4, 8};
```

#let idx = "idx"
#let val = "val"

Правила типизации:
$
E[E_idx] : [|E|] = alpha[] and [|E[E_idx]|] = int and [|E[E_idx]|] = alpha \
E[E_idx] = E_val : [|E|] = alpha[] and [|E_idx|] = int and [|E[E_val]|] = alpha \
{} : [|{}|] = alpha[] \
{E_1, E_2, ... , E_n} : [|{E_1, E_2, ..., E_n}|] = [|E_1|] = [|E_2|] = ... = [|E_n|] and [|{E_1, E_2, ..., E_n}|] = [|E_1|][]
$

=== Типизируйте следующую программу

```c
main() {
   var x, y, z, t;              //
   x = {2, 4, 8, 16, 32, 64};   // [|x|] = [|{2, 4, 8, 16, 32, 64}|] ∧ [|2|] = [|4|] = [|8|] = ... = [|64|]
   y = x[x[3]];                 // [|y|] = [|x[x[3]]|] = alpha_x ∧ [|x|] = alpha_x[] ∧ [|x[3|]] = int ∧ [|x|] = alpha_x'[] ∧ [|3|] = int
   z = {{}, x};                 // [|z|] = [|{{},x}|] ∧ [|x|] = [|{}|]
   t = z[1];                    // [|t|] = [|z[1]|] = alpha_z ∧ [|z|] = alpha_z[] ∧ [|1|] = int
   t[2] = y;                    // [|t|] = alpha_t[] ∧ [|2|] = int ∧ [|y|] = alpha_t
}
```

$
[|x|] = int[]\
[|y|] = int\
[|z|] = int[][]\
[|t|] = int[]\
$

=== Подумайте, что происходит в получившейся реализации, если в программе есть рекурсивный тип?

Программа типизируется, так как используется унификация на основе Union-Find.

= Лекция 3

=== У решетки есть максимальный и минимальный элементы ($top$, $bot$). Являются ли они точной верхней или нижней гранью какого-либо подмножества S?

Да. $top$ является точной верхней границей, а $bot$ нижней например у подмножества (количества > 1) единичной решетки. Или в решетке которая указана в примере, ${1, -, 0, +0, -0}$.

#image("lattice-example.png", width: 13em)

=== Уникальны ли они?

Не всегда. В решетке которая содержит только один элемент --- он является $top$ и $bot$ одновременно.

=== Как выглядит $top$ произведения решёток $L_1, L_2, ..., L_n$? А $bot$?

По определению произведения, верхняя: $top L_1, top L_2, ..., top L_n$. Нижняя: $bot L_1, bot L_2, ..., bot L_n$

=== Какая высота решётки произведений?

Высота решетки произведения равна сумме высот решеток-множителей.

=== Какие точные грани решётки отображений?

По определению:
$
A -> L = {[a_1 -> x_1, a_2 |-> x_2, ...]|A = {a_1, a_2, ...} and x_1, x_2, ... in L}\
f subset.eq.sq <=> forall a_i : f(a_i) subset.eq.sq g(a_i), "где" f, g in A -> L
$

Для решетки отображений $A -> L$: точная верхняя грань --- $forall a : A. a -> top$, точная нижняя грань --- $forall a : A.a -> bot$.

=== Какая высота решётки отображений?

По определению выше, высота решётки отображений равна произведению мощности множества A на высоту решётки $L: |A| * h(L)$

=== Можно ли выразить анализ типов с предыдущей лекции как анализ над решетками?

Да. Можно использовать плоскую решетку от множества возможных типов, где $top$ будет любой тип, а $bot$ — невозможность вывода типизации.

=== Можно ли выразить анализ над решётками как анализ типов?

Если ввести `Any` как $top$ (как в TypeScript, Kotlin) и `Nothing` как $bot$ (или `!` как в Rust), тогда при помощи механизма наследования можно задать отношения между типами в решетке.

= Лекция 4

=== Какая сложность структурного алгоритма для liveness analysis?

Сложность структурного алгоритма в общем случае --- $O(n dot h dot k)$, где n --- количество узлов CFG, h --- высота решетки, а k --- время вычисления constraint функции.

Для данного анализа --- $O(n dot c ^ 2)$, где $n$ --- количество узлов, $c$ --- количество переменных, $h$ -- высота решетки ($c = h - 1 ~ h$). Циклы не влияют на оценку.

=== Распишите и решите систему ограничений для примера

```c
var x, a, b;          // {}
x = input;            // {}
a = x - 1;            // {x - 1}
b = x - 2;            // {x - 1, x - 2}
while (x > 0) {       // {x - 1, x > 0}
  output a * b - x;   // {x - 1, x > 0, a * b, a * b - x}
  x = x - 1;          // {a * b, x - 1}
}                     // {a * b, x - 1}
output a * b;         // {x - 1, x > 0}
```

= Лекция 5

=== Предложите решетку для реализации анализа размера переменных

Используем интервальную решетку для аппроксимации возможных значений переменных программы во время выполнения. Множество возможных значений будет включать в себя значения от минимального до максимального возможного, а так же $-inf$ и $+inf$. С помощью widening сводим решетку.

= Лекция 6

=== Напишите вариант программы, для которой анализ открытости-закрытости файлов не показывает корректный результат

```c
if (x == 42) { 
  open();
}

if (x == 42) {
  flag = 1;
}

...

if (flag == 1) {
  close();
}
```

Так как текущий анализ следит только за $"flag"$ не понимает что при $x == 42$ будут выполняться оба условия, то в конце получим $("flag" = 1) -> *$.

=== Предложите, каким образом можно решить описанные в лекции проблемы в этой ситуации

Добавить правила которые будут учитывать ситуации в программе, когда после $("flag" = 0) -> *$ может идти $("flag" = 1)$.

= Лекция 8

=== Напишите вариант программы, для которой контекстно-чувствительный анализ знаков требует коэффициент $k>1$

```cpp
factorial(arg) {
   if (arg > 0) { return rec(arg-1); }
   return arg;
}

xyz(n) {
  factorial(-n);
}

main() {
   output xyz(42);
   output xyz(-42);
}
```

=== Приведите пример решётки, для которой контекстно-чувствительный анализ в функциональном стиле является более ресурсозатратным, чем контекстно-чувствительный анализ по месту вызова с глубиной 2

#let States = "States"
#let Var = "Var"
#let Nodes = "Nodes"

Решетка из булеана переменных для анализа живости переменных: $States = Var -> 2^Var$.

- По месту вызова с глубиной 2: $|Nodes| * 2 * |Var| * 2^(|Nodes|)$
- Функциональный стиль: $|Nodes| * |Var| * 2^(|Nodes|) * |Var| * 2^(|Nodes|)$